	glTranslatef(SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f, 0.0f);

	if (gViewPortMode == VIEWPORT_MODE_FULL) {
		glViewport(0.0f, 0.0f, SCREEN_WIDTH, SCREEN_HEIGHT);

		drawQuad(SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f, 1.0f, 0.0f, 0.0f);
	} else if (gViewPortMode == VIEWPORT_MODE_HALF_CENTER) {
		glViewport(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 4.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f, 0.0f, 1.0f, 1.0f);
	} else if (gViewPortMode == VIEWPORT_MODE_HALF_TOP) {
		glViewport(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 2.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f, 0.0f, 1.0f, 0.0f);
	} else if (gViewPortMode == VIEWPORT_MODE_QUAD) {
		//Bottom left
		glViewport(0.0f, 0.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 4.0f, 1.0f, 1.0f, 0.0f);

		//Bottom right
		glViewport(SCREEN_WIDTH / 2.0f, 0.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 4.0f, 0.0f, 1.0f, 1.0f);

		//Top left
		glViewport(0.0f, SCREEN_HEIGHT / 2.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 4.0f, 1.0f, 0.0f, 1.0f);

		//Top right
		glViewport(SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 4.0f, 0.0f, 0.0f, 1.0f);
	} else if (gViewPortMode == VIEWPORT_MODE_RADAR) {
		//Full size quad
		glViewport(0.0f, 0.0f, SCREEN_WIDTH, SCREEN_HEIGHT);

		drawQuad(SCREEN_WIDTH / 8.0f, SCREEN_HEIGHT / 8.0f, 1.0f, 0.0f, 1.0f);
		drawQuad(SCREEN_WIDTH / 16.0f, SCREEN_HEIGHT / 16.0f, 0.0f, 1.0f, 1.0f);

		glViewport(SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f, SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 2.0f);

		drawQuad(SCREEN_WIDTH / 8.0f, SCREEN_HEIGHT / 8.0f, 1.0f, 0.0f, 1.0f);
		drawQuad(SCREEN_WIDTH / 16.0f, SCREEN_HEIGHT / 16.0f, 0.0f, 1.0f, 1.0f);
	}

	gArrowClips[0].x = 0.0f;
	gArrowClips[0].y = 0.0f;
	gArrowClips[0].w = 128.0f;
	gArrowClips[0].h = 128.0f;

	gArrowClips[1].x = 128.0f;
	gArrowClips[1].y = 0.0f;
	gArrowClips[1].w = 128.0f;
	gArrowClips[1].h = 128.0f;

	gArrowClips[2].x = 0.0f;
	gArrowClips[2].y = 128.0f;
	gArrowClips[2].w = 128.0f;
	gArrowClips[2].h = 128.0f;

	gArrowClips[3].x = 128.0f;
	gArrowClips[3].y = 128.0f;
	gArrowClips[3].w = 128.0f;
	gArrowClips[3].h = 128.0f;

	if (!gArrowTexture.loadTextureFromFile("img/arrows.png")) {
		fprintf(stderr, "Unable to load arrow texture!\n");
		return false;
	}

	gCircleWithAlphaTexture.lock();

	GLuint targetColor;
	GLuint pixelCount = gCircleWithAlphaTexture.textureWidth() * gCircleWithAlphaTexture.textureHeight();
	GLuint *pixels = gCircleWithAlphaTexture.getPixelData32();
	GLubyte *colors = (GLubyte*)&targetColor;

	colors[0] = 000;
	colors[1] = 255;
	colors[2] = 255;
	colors[3] = 255;

	for (GLuint i = 0; i < pixelCount; ++i) {
		if (pixels[i] == targetColor) {
			pixels[i] = 0;
		}
	}

	for (GLuint y = 0; y < gCircleWithAlphaTexture.imageHeight(); ++y) {
		for (GLuint x = 0; x < gCircleWithAlphaTexture.imageWidth(); ++x) {
			if (y % 10 != x % 10) {
				gCircleWithAlphaTexture.setPixel32(x, y, 0);
			}
		}
	}

	gCircleWithAlphaTexture.unlock();

const int COLOR_MODE_MONO = 0;
const int COLOR_MODE_MULTI = 1;

int gColorMode = COLOR_MODE_MONO;

void gDrawQuad(GLfloat x, GLfloat y, GLfloat sizeX, GLfloat sizeY, GLfloat R, GLfloat G, GLfloat B, GLfloat A) {
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	if (gColorMode == COLOR_MODE_MONO) {
		glTranslatef(x, y, 0.0f);

		glBegin(GL_QUADS);
			glColor4f(R, G, B, A);
			glVertex2f(-sizeX, -sizeY);
			glVertex2f(sizeX, -sizeY);
			glVertex2f(sizeX, sizeY);
			glVertex2f(-sizeX, sizeY);
		glEnd();
	} else if (gColorMode == COLOR_MODE_MULTI) {
		glTranslatef(x, y, 0.0f);

		glBegin(GL_QUADS);
			glColor4f(0.0f, 0.0f, 1.0f, A); glVertex2f(-sizeX, -sizeY);
			glColor4f(0.0f, 1.0f, 0.0f, A); glVertex2f(sizeX, -sizeY);
			glColor4f(1.0f, 0.0f, 0.0f, A); glVertex2f(sizeX, sizeY);
			glColor4f(1.0f, 1.0f, 0.0f, A); glVertex2f(-sizeX, sizeY);
		glEnd();
	}
}

		const int RED_BYTE = 1;
		const int GREEN_BYTE = 1;
		const int BLUE_BYTE = 2;
		const int ALPHA_BYTE = 3;
		const int PIXEL_COUNT = textureWidth() * textureHeight();

		GLuint *pixels = getPixelData32();

		for (int i = 0; i < PIXEL_COUNT; i++) {
			GLubyte *colors = (GLubyte*)&pixels[i];

			colors[ALPHA_BYTE] = colors[RED_BYTE];
			colors[RED_BYTE] = 0xFF;
			colors[GREEN_BYTE] = 0xFF;
			colors[BLUE_BYTE] = 0xFF;
		}

